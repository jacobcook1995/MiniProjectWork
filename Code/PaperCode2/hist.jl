#!/usr/bin/env julia
# hist.jl
# A script that reads in data generated by gillespie simulation of the two species
# genetic switch. this data is then used to perform analysis
#
# Author: Jacob Cook
# Date: September 2018

using Plots
using StatsBase
using LsqFit
using LaTeXStrings
import PyPlot # this is necessary to avoid a world age error when using GR in function

# function to open my 4D histogram
function openhist(input_file::String)
    vol = convert(Int64,(countlines(input_file)/4) - 1.5)
    hist = Array{Float64,4}(undef,vol,vol,2,2)
    a = 0
    i = 1
    j = 1
    k = 1
    l = 1
    T = 0
    open(input_file, "r") do in_file
        # Use a for loop to process the rows in the input file one-by-one
        for line in eachline(in_file)
            # parse line by finding commas
            if line[1] == '#'
                a += 1
                i = 1
                j = 1
                if l == 1 && a != 1
                    l = 2
                elseif a != 1
                    l = 1
                    k = 2
                end
            else
                if a == 5
                    T = parse(Float64,line)
                else
                    # need to think about how to do the parsing here
                    L = length(line)
                    comma = fill(0,vol+1)
                    j = 1
                    for i = 1:L
                        if line[i] == ','
                            j += 1
                            comma[j] = i
                        end
                    end
                    comma[end] = L+1
                    for j = 1:vol
                        hist[i,j,k,l] = parse(Float64,line[(comma[j]+1):(comma[j+1]-1)])
                    end
                    i += 1
                end
            end
        end
    end
    return(hist)
end
# ps = [ k, kmin, q, qmin, K, Kmin, Q, Qmin, r, f, Ω ]
# total force
function f!(ps::Array{Float64,1},f::Array{Float64,1},pos::Array{Float64,1})
    f[1] = ps[1]*ps[9]/(ps[9]+ps[10]*pos[2]^2) + ps[6] - (ps[2]+ps[5])*pos[1]
    f[2] = ps[3]*ps[9]/(ps[9]+ps[10]*pos[1]^2) + ps[8] - (ps[4]+ps[7])*pos[2]
    return(f)
end
# Conservative force
function fc!(ps::Array{Float64,1},f::Array{Float64,1},pos::Array{Float64,1})
    f[1] = -(ps[2]+ps[5])*pos[1]
    f[2] = -(ps[4]+ps[7])*pos[2]
    return(f)
end
# Dissaptive force
function fd!(ps::Array{Float64,1},f::Array{Float64,1},pos::Array{Float64,1})
    f[1] = ps[1]*ps[9]/(ps[9]+ps[10]*pos[2]^2) + ps[6]
    f[2] = ps[3]*ps[9]/(ps[9]+ps[10]*pos[1]^2) + ps[8]
    return(f)
end
# noise
function fii!(ps::Array{Float64,1},f::Array{Float64,1},pos::Array{Float64,1})
    f[1] = -(ps[2]+ps[5])
    f[2] = -(ps[4]+ps[7])
    return(f)
end
# noise
function D!(ps::Array{Float64,1},D::Array{Float64,1},pos::Array{Float64,1})
    D[1] = sqrt(ps[1]*ps[9]/(ps[9]+ps[10]*pos[2]^2) + ps[6] + (ps[2]+ps[5])*pos[1])/(2*ps[11])
    D[2] = sqrt(ps[3]*ps[9]/(ps[9]+ps[10]*pos[1]^2) + ps[8] + (ps[4]+ps[7])*pos[2])/(2*ps[11])
    return(D)
end
# ps = [ k, kmin, q, qmin, K, Kmin, Q, Qmin, r, f, Ω ]
# function to plot powers from Tome Langevin method
function power(hist::Array{Float64,2},ps::Array{Float64,1})
    lA = size(hist,1)
    lB = size(hist,2)
    # make arrays to store powers
    ΦC = zeros(lA,lB)
    ΦD = zeros(lA,lB)
    f = zeros(2)
    fc = zeros(2)
    fd = zeros(2)
    fii = zeros(2)
    D = zeros(2)
    for j = 1:lB
        for i = 1:lA
            pos = [(i-1),(j-1)]/ps[11]
            f = f!(ps,f,pos)
            fc = fc!(ps,fc,pos)
            fd = fd!(ps,fd,pos)
            fii = fii!(ps,fii,pos)
            D = D!(ps,D,pos)
            ΦC[i,j] = (fc[1]*f[1]/D[1] + fc[2]*f[2]/D[2] + sum(fii))*hist[i,j]
            ΦD[i,j] = (fd[1]*f[1]/D[1] + fd[2]*f[2]/D[2])*hist[i,j]
        end
    end
    # println(argmax(hist))
    heatmap(ΦC[1500:2500,1:15])
    savefig("../Results/trail.png")
    heatmap(ΦD[1500:2500,1:15])
    savefig("../Results/trail2.png")
    heatmap(hist[1500:2500,1:15])
    savefig("../Results/trail3.png")
    heatmap(ΦC[1500:2500,1:15].+ΦD[1500:2500,1:15])
    savefig("../Results/trail4.png")
    println(sum(ΦC))
    println(sum(ΦD))
    return(nothing)
end

# function to open my 4D histogram
function openhist2(input_file::String)
    vol = convert(Int64,countlines(input_file) - 3)
    hist = Array{Float64,2}(undef,vol,vol)
    a = 0
    i = 1
    j = 1
    T = 0
    open(input_file, "r") do in_file
        # Use a for loop to process the rows in the input file one-by-one
        for line in eachline(in_file)
            # parse line by finding commas
            if line[1] == '#'
                a += 1
                i = 1
                j = 1
            else
                if a == 2
                    T = parse(Float64,line)
                else
                    # need to think about how to do the parsing here
                    L = length(line)
                    comma = fill(0,vol+1)
                    j = 1
                    for i = 1:L
                        if line[i] == ','
                            j += 1
                            comma[j] = i
                        end
                    end
                    comma[end] = L+1
                    for j = 1:vol
                        hist[i,j] = parse(Float64,line[(comma[j]+1):(comma[j+1]-1)])
                    end
                    i += 1
                end
            end
        end
    end
    return(hist)
end

function main()
    # First check that an argument for naming has been provided
    if length(ARGS) == 0
        println("Error: Need to provide an argument to name output with.")
        return(nothing)
    # then check that a system volume has been provided
    elseif length(ARGS) == 1
        println("Error: Need to provide an argument to set system volume.")
        return(nothing)
    end
    # Then take system volume Ω, check if provided value is integer
    Ω = 0
    try Ω = parse(Int64,ARGS[2])
    catch y
        if isa(y, ArgumentError) # would only really expect an argument error
            println("Error: System volume has to be integer.")
            return(nothing)
        end
    end
    # define file names to read in
    input_wA = "../Results/WaitTime/wA$(ARGS[1])V$(ARGS[2]).csv"
    input_wB = "../Results/WaitTime/wB$(ARGS[1])V$(ARGS[2]).csv"
    lwA = countlines(input_wA)
    wA = zeros(lwA)
    i = 0
    open(input_wA, "r") do in_file
        for line in eachline(in_file)
            i += 1
            wA[i] = parse(Float64,line)
        end
    end
    lwB = countlines(input_wB)
    wB = zeros(lwB)
    i = 0
    open(input_wB, "r") do in_file
        for line in eachline(in_file)
            i += 1
            wB[i] = parse(Float64,line)
        end
    end
    nb = 500
    hA = fit(Histogram,wA,nbins=nb,closed=:left)
    hB = fit(Histogram,wB,nbins=nb,closed=:left)
    maxA, MA = findmax(hA.weights)
    binsA = hA.edges[1]
    # point behind which should ignore data
    dataA = convert(Array{Float64,1},hA.weights[MA:end])
    tsA = zeros(length(binsA)-MA)
    for i = MA:length(binsA)-1
        tsA[i-MA+1] = 0.5*(binsA[i-1]+binsA[i])
    end
    maxB, MB = findmax(hB.weights)
    binsB = hB.edges[1]
    # point behind which should ignore data
    dataB = convert(Array{Float64,1},hB.weights[MB:end])
    tsB = zeros(length(binsB)-MB)
    for i = MB:length(binsB)-1
        tsB[i-MB+1] = 0.5*(binsB[i-1]+binsB[i])
    end
    # set up model to be fitted to
    @. model(x, p) = p[1]*exp(-x*p[2])
    p0 = [10000.0, 0.5]
    fitA = curve_fit(model,tsA,dataA,p0)
    fitB = curve_fit(model,tsB,dataB,p0)
    pA = fitA.param
    pB = fitB.param
    # make forms of exponential to plot
    rangeA = collect(0.0:1.0:tsA[end])
    rangeB = collect(0.0:1.0:tsB[end])
    A = model(rangeA,pA)
    B = model(rangeB,pB)
    # actually visulise the histograms
    pyplot()
    Lx = latexstring("Time\\,\\tau")
    Ly = L"P(\tau)"
    bar(hA,label="",linecolor=:blue,dpi=300,fillalpha=1.0,fillcolor=:blue)
    plot!(rangeA,A,label="",grid=false,xlabel=Lx,ylabel=Ly,xticks=false,yticks=false,guidefontsize=20)
    savefig("../Results/wA.png")
    bar(hB,label="",linecolor=:blue,dpi=300,fillalpha=1.0,fillcolor=:blue)
    plot!(rangeB,B,label="",grid=false,xlabel=Lx,ylabel=Ly,xticks=false,yticks=false,guidefontsize=20)
    savefig("../Results/wB.png")
    return(nothing)
end

# function to read in histogram and then find the powers associated
function main2()
    # read in histogram
    input_hist = "../Results/WaitTime/hist$(ARGS[1])V$(ARGS[2]).csv"
    input_ps = "../Results/WaitTime/ps$(ARGS[1])V$(ARGS[2]).csv"
    hist = openhist2(input_hist)
    # sum over promotor dimensions
    # hist = dropdims(sum(hist,dims=4),dims=4)
    # hist = dropdims(sum(hist,dims=3),dims=3)
    heatmap(hist)
    savefig("../Results/HeatMap.png")
    ps = zeros(11)
    i = 0
    open(input_ps, "r") do in_file
        for line in eachline(in_file)
            i += 1
            ps[i] = parse(Float64,line)
        end
    end
    # ps = [ k, kmin, q, qmin, K, Kmin, Q, Qmin, r, f, Ω ]
    # ps[1] = ps[1]/ps[11]
    # ps[6] = ps[6]/ps[11]
    # ps[3] = ps[3]/ps[11]
    # ps[8] = ps[8]/ps[11]
    # ps[10] = ps[10]*(ps[11]^2)
    power(hist,ps)
    return(nothing)
end

@time main()
# @time main2()
